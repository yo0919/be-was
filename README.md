# java-was-2023

Java Web Application Server 2023

## 프로젝트 정보 

이 프로젝트는 우아한 테크코스 박재성님의 허가를 받아 https://github.com/woowacourse/jwp-was 
를 참고하여 작성되었습니다.

## 깃의 사실과 오해
+ Q1. git init을 수행하면 현재디렉토리가 로컬 저장소가된다?   
A1. NO, .git이 저장소가된다   

+ Q2. git의 객체에는 무엇이 있을까?   
A2. Blob tree commit Tag   
commit 안에는 blob과 tree가 들어있다.   

+ Q3. 저장은 어느시점부터될까? 파일 만드는시점? Git add? commit? + 각 명령어의 기능   
A3. Git add    
stage는 무엇인가? - 커밋을 만들기위한 준비공간   
commit이 뭔데? 일종의 세이브 포인트? 우리의 작업내용의 스냅샷   

+ Q4. 커밋을 하고나면 스테이지는 깨끗하게 비워진다?   
A4. 안비워진다.(작업디렉토리와 스테이지와 저장소가 모두 같을때 비어있다고 표현)    
마지막 커밋에는 트리가 있고, 그 트리안에는 블롭들이 들어있다.   

+ Q5. 스테이지의 변경사항을 취소하려면 스테이지를 직접 조작하는 명령인 'git rm --cached <파일이름>' 을 사용해서 변경사항을 스테이지에서 제거하면 된다.   
A5. YES   

+ Q6. Git status는 [...]들을 비교해서 보여주는 명령어이다   
A6. stage HEAD commit   

+ Q7. 파일의 내용을 수정하고 커밋하면 GIT은 공간 효율을 위해 변경사항만 저장한다.   
A7. NO (전체 파일이 저장된다.)   
깃은 변경사항이 아니라 전체를 저장하기때문에 순식간에 switch가 가능하다. 성능을 위해 전체저장!    

+ Q8. a.txt를 새로 만들고 새로운 디렉토리에 복사한 후 add, commit 한 후 새로운 브랜치를 만들어 변경했다. 이때 blob이 새로 생성되는가?    
A8. NO (깃에서 똑같은 파일을 여러개만들어도 더이상의 blob이 생기지않고 하나만 올라간다.)    
## HTTP

* DNS란?   
  - 사람이 볼수있는 주소를 서버가 인식할수있도록 IP로 변환하는것   
  - 그럼 항상 접근할때마다 DNS로 변환하나? NO
   
* 로드밸런서(Load Balancer)?   
  - 내 코드가 JVM을 통해 시작될때 DNS를 이용하여 다른 곳에서 정보를 얻어올때 필요하다?   
  - 예를들어 외부 API로 부터 정보를 받아올때   
  - 로드밸런서가 고유한 주소를 가지고있고, 우리는 요청을 그 주소로 보낸다.    
  - 주로 사용되는것은 L4, L7. 이들은 주기적으로 인스턴스의 헬스체크를 한다.   
  - HTTP가 가지고있는 특성, 즉 어떠한 서버군에 요청하든 항상 같은 값을 반환해야하기 때문에 로드밸런서는 거의 필수적이다.
* JVM DNS캐싱
  - DNS캐싱으로 인해 계속해서 잘못된 접근을 할수도있다.
  - 하지만 항상 DNS요청을 하기엔 부하가 걸리기에 사용하는것이다.
  - 그럼 오류가 생길땐 어떻게하나? 주기적으로 dns서버에 요청하여 캐쉬를 전체업데이트!
* OSI 7계층
  - 7계층(application layer) : 사용자가 이해할수 있는 인터페이스   
    -대표 프로토콜 : HTTP
  - 4계층(transport layer)    
    -대표 프로토콜 : TCP,UDP,~~IP~~(네트워크레이어)
    TCP와 UDP의 가장 큰 차이? 보안의 정도
* HTTP
  - 특징 : stateless, coneectionless, self-descriptive, uniformed(protocol)
  - 크게 request와 response로 구분가능, RESTful(Representational State Transfer)
    + Request : method, URL/path, HTTP version
    * method : GET, POST, PATCH, PUT, DELETE(결국 CRUD)
      PUT,PATCH는 둘다 수정을 위한것이지만, PUT은 전체수정, PATCH는 부분수정
## CIDR

* CIDR?
  - 용도 : Resource를 얼마나 사용할 수 있는지 사이즈 계산     
    + 예를들어 10.0.0.0/32 IP를 리소스로 보고 얼마까지 쓸 수 있는지 알려주는것     
  - 32란 무엇인가? 32개를 마스크를 씌워서 고정한다는 말      
    + 10.0.0.0에는 8*4로 32개를 고정      
  그렇다면 10.0.0.0/16 이면 상위 16개 고정하고, 2^16개가 사용가능

## WAS 1주차

1. Concurrent 사용하기 - native 쓰레드의 단점이 무엇인지, Concurrent 패키지의 추상화, Project LOOM -> virtual thread   
2. 정적인 페이지 응답하기 - HTTP Request 를 읽어서 URL 추출 -> 파일에서 읽어서 돌려주기 (NID, io)
3. GET 으로 회원가입 - ? 인자 파싱하고 자체 DB(hashmap도 ok) 에 저장하면 OK, Redirect 해도좋고~
4. 스타일시트 - content type -MIME

## 배워갈 점
* 빠르게 구현하고 리팩토링(정답만 찾기보단 그 과정에 집중하자)
* 커밋메세지 자세히 쓰기
  - 커밋을 작게 나누자(메서드 하나당하나?)
  - 두 줄이상??
* 빌드 도구 활용해서 공부하기
  - gradle 사용법
* 테스트 잘하기
  - junit 5 + AssertJ를 많이 사용한다
  - 주석도 꼭 필요한 존재(테스트코드도 주석의 역할을 할때가 있다)
  - 테스트 코드 짜기가 어려우면 코드를 고치라는 신호일수도 있다.
  - BDD방법에 대해 찾아보고 시도해보자
* 코드 포맷 (Lint) 신경쓰기
  - EOF
  - 불필요한 코드 주석을 제거하고, 나중에 구현이 필요하다고 하면 //TODO활용
* MVC + Service 꼭 사용해야 하나?
  - 나도 가지고있는 고민이랑 비슷하다..
  - 내생각엔 MVC에 대한 개념을 확실히 가지고있되, 상황에 맡게 적용할수있는 능력을 키우는게 중요할것같다.
  - 내가 사용한 모든 기술에는 근거가 있어야 한다.
* 드미터의 법칙??
  - 메서드 호출할때 나와 관계없는 메서드를 호출하면 안된다.
  - 특정 객체가 가능한 한 적은 수의 다른 객체들과만 상호작용하고, 그 상호작용도 가능한 한 간단하게 유지해야 한다.
* 기타 찾아볼만한 사항
  - 일급 컬랙션
  - 객체지향 체조
  - SOLID 원칙

## JVM
 - JDK는 JRE에 개발툴을 추가한것이다.
 - JIT이 뭐지?
   * 간단히 말하면 코드를 기계어로 변환해서 필요할때마다 사용할수 있도록 한다.
 - VM의 종류 JDK의 종류와 작동원리를 알아야한다.
 - JVM의 간단한 작동원리
   * 클래스파일 -> Class Loader Subsystem
   * CLS에서 런타임데이터와 정보를 주고받는다.
   * 런타임데이터는 Execution Engine(JIT Compiler,Garbage Collector)랑 정보교환
 - Java에서는 필요할때만 객체를 로딩한다? 실제필요한시점이 되기까지 클래스파일은 JVM은 로딩하지않는다.
 - CLS에 로더가 3개가있다 main.java를 불러오는 곳은 application class loader.     
   그말은 즉 main을 가장먼저 불러오는것이 아니고 더 먼저 불러오는게 있다.    
   Bootstrap Class Loader에서 java.lang(기본클래스)를 먼저 불러온다.
   그 다음 Extension Class Loader 그 다음에야 main을 불러온다. 이거하나만!
 - 검증-준비-해석의 단계로 이뤄진다
   * 검증 : 예를들어 0xCAFEBABE로 시작하는지
   * 준비 : int null등 저장될수있는 공간을 만든다. 스태틱영역의 변수들은 메소드영역에 들어간다. 매소드영역 = C에서의 데이터영역
 - 코드 스태틱변수 : 메소드, 객체 : 힙, 지역변수 : 스택
 - 쓰레드가 스택의 개수만큼 생긴다. 즉 쓰레드는 자신만의 스택을 가지고있다.
 - 자바의 상수풀은 메서드영역, 문자열은 힙영역에 들어있다(원래는 메서드였다 30여년전).
## 데이터베이스
 - 데이터베이스의 null이란?
   그값이 무엇인지 알수없을때
 - 파일시스템의 종류
   * NTFS (New Technology File System): 주로 윈도우 시스템에서 사용
   * EXT4 (Fourth Extended Filesystem): 리눅스 시스템에서 주로 사용되며, 큰 파일 지원, 저널링 기능, 데이터 복구 기능 등을 제공
   * APFS (Apple File System): 애플의 최신 파일 시스템으로, SSD 최적화, 더 나은 암호화, 공간 공유 등의 기능을 제공
   * XFS: 리눅스 시스템에 주로 사용되며, 높은 성능, 확장성, 저널링 지원 등이 특징
   * trfs (B-tree File System): 최신 파일 시스템 중 하나로, 고급 기능을 많이 제공
 - Linux MySQL 설치
   * vmware를 사용해서 arch linux를 이용해서 MySQL을 설치해야하는 미션
   * x86_64랑 애플실리콘의 ARM의 호환문제때문에 많이 진행하진 못했지만, 예전에 윈도우즈 노트북에서 리눅스 듀얼부팅을 시도했을때와 비슷한느낌을 받았다.
  
<img width="628" alt="스크린샷 2024-02-01 오전 10 25 22" src="https://github.com/yo0919/be-was/assets/104425318/3bf1919a-3dd4-48b0-9b39-92b7ef02990a">

